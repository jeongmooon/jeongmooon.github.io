<hr />

# 쿠키(Cookie)/세션(Session)/JWT(JSON Web Token)

## 배경

> 쿠키와 세션에 대해 알아보기 전, 생기게된 배경을 알아봐야함<br>
> **`HTTP`** 통신은 기본적으로 서버와 클라이언트간 통신이 끝난다면 연결이 끊어지기 때문에 서버에서는 클라이언트의 상태를 알 수가 없다.
> 서버에서는 클라이언트의 상태를 알아야 하는 상황이 와버렸음!(로그인 유지)
> 그래서 HTTP의 특성을 보완하기 위해 생긴 것이 쿠키(Cookie)와 세션(Session)이다. 

---

## 쿠키(Cookie)

`쿠키`란 클라이언트 로컬에 저장되는 **`Key-Value`** 형태의 데이터

- 클라이언트에서 서버에 Request 시 에 쿠키를 담아 보낸다면 쿠키의 상태 데이터를 읽고 클라이언트의 상태를 파악하여 그에 맞춘 Response 제공
- 문제점 : 쿠키의 출발점은 **클라이언트**
    - 때문에 해커도 쿠키를 변조가 가능하게 됨

- 쿠키 결과 값 확인
![cookie 결과](https://jeongmooon.github.io/img/study/cookie.png)

---

## 세션(Session)

`세션`이란 기존에 쿠키는 클라이언트에 저장했다면, 세션은 서버에 저장을 한다.
- 세션도 기본적으로는 쿠키를 사용함
- 쿠키로 저장하는 값은 세션ID로 상태 데이터들은 서버에 저장을 함
- 클라이언트에서 Request를 하면 서버에서는 세션을 생성하고 세션ID를 쿠키에 담아 Response를 한다.
- 세션은 기본적으로 브라우저가 종료되면 소멸한다.

- 문제점 : 쿠키를 사용하기 때문에 동일한 문제점이 발생은 한다.
    - 세션ID를 탈취(세션 하이재킹)해서 변경을 해서 다른 사용자로 로그인함

### 세션 하이재킹(Session Hijacking)
`세션 하이재킹` 이란 해커가 사용자의 세션ID를 탈취하여 세션의 권한을 가로채는 공격 기법

#### 세션 하이재킹 주요 기법
1. 세션 스니핑(Session Sniffing)
    - 네트워크 트래픽을 도청하여 세션ID를 탈취하는 공격
    - Http요청은 암호화 되어 있지 않아서 노출이 될 수 있음

2. 크로스 사이트 스크립팅(XSS, Cross-Site Scripting)
    - 웹 어플리케이션에서 취약점을 이용하여 악성 코드를 심어서 세션ID 탈취
    - 해커가 사용자가 방문하는 페이지에서 악성js를 넣어 놔서 쿠키에서 세션ID 수집

3. 세션 고정(Session Fixation)
    - 해커가 미리 생성하거나 자신의 세션ID를 사용자에게 주입, 강제로 사용하게하여 세션 탈취
    - 해커가 고정된 세션ID를 URL에 포함시킨 뒤 사용자가 해당 링크를 클릭하도록 유도

4. 피싱(Phishing)
    - 사용자의 개인정보나 세션ID를 속여서 빼내기 위해 가짜 웹사이트나 이메일 이용
    - 가짜 로그인 페이지를 만들어서 로그인용 정보 획득

5. 멜웨어(Malware)
    - 사용자의 시스템에 악성 소프트웨어를 심어서 세션ID를 직접 탈취
    - 키로깅(keylogging)을 통해서 세션 쿠키와 기타 정보를 수집

---

## JWT(JSON Web Token)
`JWT` 란 `JSON Web Token`의 약자로 속성 정보(Claim)을 JSON 데이터 구조로 표현한 토큰으로써 네트워크를 통해서 서로 다른 장치끼리 안전하게 전송하기 위해 설계 됨

- JWT는 세 파트로 나눠지며 **헤더(Header)**, **페이로드(Payload)**, **서명(Sinature)**로 구성이 됨

- JWT는 `리프레쉬토큰(Refresh Token)`이랑 `엑세스토큰(AccessToken)` 을 사용해서 인증을 유지함

### 헤더(Header)
해시 암호화 알고리즘과 토큰의 타입으로 구성
- 첫 번째는 HMAC, SHA256, RSA와 같은 서명 생성에 사용된 해시 알고리즘
- 두 번째는 토큰의 유형(JWT)

- 헤더 구성 요소 예)
```
----------Base64-------------
|   {                       |
|       "alg" : "HS256",    |
|       "type" : "JWT"      |
|   }                       |
-----------------------------
eyJhbGciOiJIUzI1NiJ9
```

### 페이로드(Payload)
토큰에 담은 클레임(Claim)을 포함한 내용
- Payload에 담은 정보의 한 `'조각'`을 `클레임`이라고 부르며 key/value 한쌍으로 이루어짐
- 토큰에 여러개의 클레임을 담을 수 있음
- 클레임의 정보는 등록된 (registered) 클레임, 공개 (public) 클레임, 비공개 (private) 클레임으로 세 종류
    - 등록된 클레임 : 토큰 정보를 표현하기 위해 이미 정해진 종류의 데이터들로, 모두 선택적으로 작성이 가능하며 사용할 것을 권장
        - iss: 토큰 발급자(issuer)
        - sub: 토큰 제목(subject)
        - aud: 토큰 대상자(audience)
        - exp: 토큰 만료 시간(expiration)
        - nbf: 토큰 활성 날짜(not before)
        - iat: 토큰 발급 시간(issued at)
        - jti: JWT 토큰 식별자(JWT ID)
    - 공개 클레임 : 사용자 정의 클레임으로 공개용 정보를 위해 사용
    - 비공개 클레임 : 사용자 정의 클레임으로 서버와 클라이언트 사이에 임의로 지정한 정보를 저장

- 클레임 예시

| Claim 키 | 설명 | 보안/기능성
|----------------------|---------------------------------------|------------------------------------------|
tokenType | access or refresh | 토큰 타입 지정
role / auth | 사용자 권한 (예: USER, ADMIN) | 인가 용도
iss (issuer) | 토큰 발급자 정보 | 위조 토큰 구분
aud (audience) | 토큰 사용 대상자 | 잘못된 대상 차단
iat (issued at) | 발급 시각 (timestamp) | 토큰 갱신 여부 판단
jti (JWT ID) | 고유 ID (ex. UUID) | 토큰 중복 방지, 블랙리스트 관리
ip | 토큰 발급 당시 클라이언트 IP |  탈취 방지 (IP 체크)
ua | User-Agent (브라우저, 앱 정보 등) |  디바이스 고정 검사
deviceId | 디바이스 식별값  | 특정 기기 전용 토큰 처리


- 페이로드 구성 요소 예)
```
----------Base64-----------------
|   {                           |
|       "sub" : "123나d",       |
|       "userId" : "admin",     |
|       "type" : "admin",       |
|       "jti" : "admdfasadfin"  |
|   }                           |
---------------------------------
eyJzdWIiOiJhZG1pbjMiLCJ0b2tlblR5cGUiOiJyZWZyZXNoIiwiZGV2aWNlSWQiOiJhNDUwMGZkYzZmYjM2YzM0YjliZTYwMzM2MWJlOWNjZWZmZTc4MGFiYjcwMTQ0MDJhYmY3YjQ2OWIxYjVjYTBjIiwiZXhwIjoxNzQ1OTE4MDU2fQ
```

### 서명(Sinature)
Header, Payload, Secret Key를 합쳐서 암호환 결과 값
- HS256( base64UrlEncode(header) + "." + base64UrlEncode(payload), Secret key)

- 서명 구성 요소 예)
```
YIhtdUeZKQF6iVwJmTN_2ABDTkezbDagExCrhQ0ENAk
```

### 엑세스토큰(AccessToken)/리프레쉬토큰(Refresh Token)

> `엑세스토큰(AccessToken)`은 사용자에 대한 정보를 담고 서비스에 접근(Access)를 가능한 토큰을 의미<br>
> `리프레쉬토큰(Refresh Token)`은 별다른 정보를 담고 있지는 않음. 대신 엑세스 토큰이 만료되었을 때 서버에서 이를 확인하여 새로운 엑세스 토큰을 발급해주기 위해 사용

#### 엑세스토큰(AccessToken)
- 일반적으로 짧은 유효기간을 가지고 인증을 위해 사용이 됨

#### 리프레쉬토큰(Refresh Token)
- 만료된 엑세스토큰을 교체하기 위해 사용되는 토큰.
- 일반적으로 리프레쉬토큰은 엑세스토큰보다 더 긴 유효기간을 가지고 있음

#### 두가지를 사용 하는 이유
- 엑세스토큰만 가지고 인증을 길게잡고 사용을 한다면 상대적으로 통신할 때 노출 횟수가 늘어나고 그 만큼 해킹에 대한 리스크가 올라간다.
- 그렇다고 짧게 잡는다면 사용자가 계속 로그인해야하는 상황이 발생한다.
- 때문에 엑세스토큰이 만료 시에 리프리쉬토큰으로 엑세스토큰을 갱신하여 로그인을 유지한다.

```
+----------------+
|   API 호출     |
+----------------+
        |
        v
+-----------------------+
| 엑세스 토큰이 유효한가? |
+-----------------------+
     | Yes       | No
     v           v
+------------+  +------------------------+
| 정상 호출  |  | 리프레시 토큰이 유효한가? |
+------------+  +------------------------+
     |              | Yes              | No
     |              v                  v
     |       +----------------+  +------------+
     |       | 새로운 액세스   |  |  오류 발생  |
     |       | 토큰 발급       |  +------------+
     |       +----------------+
     |              |
     +--------------+
            |
            v
     +---------------+
     | 응답 반환     |
     +---------------+

``` 

1. 클라이언트에서 API 호출 시에 엑세스 토큰이 유효한지 확인한다.
    - 엑세스 토큰이 유효하다면 응답을 반환
2. 엑세스 토큰이 만료되었다면 클라이언트에서 리프레쉬 토큰을 추가로 담아서 API를 호출한다.
    - 엑세스 토큰이 만료된 것이 아닌 이유로 유효하지 않은 경우에 오류 응답을 반환
3. 리프레쉬 토큰이 유효하다면 새로운 엑세스 토큰을 응답 헤더에 담아서 정상 응답 반환한다.
    - 리프레쉬 토큰이 유효하지 않은 경우 오류 응답을 반환
    - 만료된 엑세스 토큰과 유효한 리프레쉬 토큰이 함께 요청 헤더에 담겨 있다면 엑세스 토큰을 재발급 한다. 

---

## 결론
HTTP는 상태를 유지하지 않기 때문에 사용자의 상태를 관리하기 위해 쿠키와 세션, JWT 같은 기술이 필요하다.

>  - **쿠키(Cookie):** 클라이언트에 상태정보를 저장하지만 변조의 위험이 존재
>  - **세션(Session):** 상태정보는 서버에 저장하고, 클라이언트에 세션ID만 쿠키로 저장하지만, 세션ID 탈취(세션 하이재킹)의 위험이 존재
>  - **JWT(JSON Web Token):** 상태정보를 토큰으로 클라이언트에 저장하며, 액세스 토큰과 리프레쉬 토큰의 조합을 통한 보안성 편의성 고려한 인증 방식

결론적으로 보안성과 사용자 경험을 위해 현재는 JWT의 AccessToken과 RefreshToken구조가 많이 채택이 되고 있지만, 각 방식마다 용도에 맞게 사용되어야함
<hr />